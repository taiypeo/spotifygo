package tokenauth

import (
	"encoding/json"
	"fmt"
	"strings"
	"time"

	"github.com/taiypeo/spotifygo/apierrors"
	"github.com/taiypeo/spotifygo/requests"
)

// PKCERefreshableAuthToken is a struct that represents a token that
// can refresh after expiring. It can be generated by
// authorization code flow with proof key for code exchange (PKCE).
// While identical to RefreshableAuthToken, a new struct is necessary
// because the refreshing behavior is different.
type PKCERefreshableAuthToken struct {
	RefreshToken string
	ScopedAuthToken
}

// NewPKCERefreshableAuthToken creates a new PKCERefreshableAuthToken.
// clientID is the Spotify application client id;
// code is the authorization code obtained after the user is redirected to redirectURI;
// redirectURI is the same redirect_uri that was supplied when requesting the authorization code;
// codeVerifier is the same code verifier that you generate in the beginning of this method
func NewPKCERefreshableAuthToken(
	authCode,
	redirectURI,
	clientID,
	codeVerifier string,
) (PKCERefreshableAuthToken, apierrors.TypedError) {
	payload := fmt.Sprintf(
		"client_id=%s&grant_type=authorization_code&code=%s&redirect_uri=%s&code_verifier=%s",
		clientID,
		authCode,
		redirectURI,
		codeVerifier,
	)

	response, err := requests.PostAuthorization(map[string]string{}, payload)
	if err != nil {
		return PKCERefreshableAuthToken{}, err
	}

	var decodedResponse struct {
		AccessToken  string `json:"access_token"`
		TokenType    string `json:"token_type"`
		Scope        string `json:"scope"`
		ExpiresIn    int64  `json:"expires_in"`
		RefreshToken string `json:"refresh_token"`
	}
	if err := json.Unmarshal([]byte(response.JSONBody), &decodedResponse); err != nil {
		return PKCERefreshableAuthToken{}, apierrors.NewBasicErrorFromError(err)
	}

	if decodedResponse.TokenType != "Bearer" {
		return PKCERefreshableAuthToken{},
			apierrors.NewBasicErrorFromString("token_type is not Bearer")
	}

	var createdPKCERefreshableAuthToken PKCERefreshableAuthToken
	createdPKCERefreshableAuthToken.CreationTime = time.Now()
	createdPKCERefreshableAuthToken.AccessToken = decodedResponse.AccessToken
	createdPKCERefreshableAuthToken.ExpiresIn = decodedResponse.ExpiresIn
	createdPKCERefreshableAuthToken.RefreshToken = decodedResponse.RefreshToken
	createdPKCERefreshableAuthToken.Scope = strings.Split(decodedResponse.Scope, " ")
	return createdPKCERefreshableAuthToken, nil
}

// Refresh refreshes the access token using the refresh token.
// clientId is the Spotify application client id.
func (auth *PKCERefreshableAuthToken) Refresh(clientID string) apierrors.TypedError {
	payload := fmt.Sprintf(
		"grant_type=refresh_token&refresh_token=%s&client_id=%s",
		auth.RefreshToken,
		clientID,
	)

	response, err := requests.PostAuthorization(map[string]string{}, payload)
	if err != nil {
		return err
	}

	var decodedResponse struct {
		AccessToken  string `json:"access_token"`
		TokenType    string `json:"token_type"`
		Scope        string `json:"scope"`
		ExpiresIn    int64  `json:"expires_in"`
		RefreshToken string `json:"refresh_token"`
	}
	if err := json.Unmarshal([]byte(response.JSONBody), &decodedResponse); err != nil {
		return apierrors.NewBasicErrorFromError(err)
	}

	if decodedResponse.TokenType != "Bearer" {
		return apierrors.NewBasicErrorFromString("token_type is not Bearer")
	}

	auth.CreationTime = time.Now()
	auth.AccessToken = decodedResponse.AccessToken
	auth.ExpiresIn = decodedResponse.ExpiresIn
	auth.Scope = strings.Split(decodedResponse.Scope, " ")
	auth.RefreshToken = decodedResponse.RefreshToken

	return nil
}
